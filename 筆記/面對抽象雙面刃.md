# 面對抽象雙面刃

http://www.ithome.com.tw/voice/106025

程式碼採取抽象化的設計後，在維護性的考量上，也許會遭到批評或反對而回到重複、耦合的作法，然而，這也讓許多人思考：難道，我的團隊成員程度爛到只能規定他們只能用複製、貼上？

在軟體開發中，為了不重複、解耦合、易維護等各種彈性需求，程式碼必然地都會有一定程度往抽象化發展，然而，這是一把雙面刃，也容易形成兩個極端：抽象化的極端擁護者，以及抽象化的極端反對者。

## 複製、貼上，好棒棒(TQ)！

無論是結構化程式設計、物件導向，或者函數式等典範，無論是狹義的設計模式或廣義的各種模式，只要程式碼是為了追求涵蓋更多的需求，程式碼必然都會朝向一定程度的抽象化發展，一個最簡單的例子：排序，若有針對整數排序的 `sortInt()` 與字串排序 `sortStr()` 兩個函式，其中使用了相同的排序演算法，其程式碼內容必然相近，若因此而定義了一個通用的 `sort()` 函式，相對 `sortInt()` 、 `sortStr()` 來說， `sort()` 函式就是沒那麼具體！

然後，某天程式碼審查（Code review）時，某位主管看到 `sort()` 就開飆了：「你寫這個是三小？ `sortInt()` 、 `sortStr()` 不是用的好好的嗎？」，你辯解著：「可是這樣排序日期或其他物件也可以用 `sort()` 啊！」，主管繼續開飆：「你是不會複製、貼上寫個 `sortDate()` 嗎？ 你這樣會害我還要追到 `sort()` 才知道它在幹嘛！」

## 抽象之惡

不良的抽象化確實有著不好的名聲。在《約耳趣談軟體》的（別讓架構太空人嚇到你）中，一開始就是個鮮明的案例：「他們看到人們要傳送文書處理檔案給別人，又看到人們要傳送試算表給別人，然後就會發現裡面有一個通用的模式：傳送檔案。這已經是一層的抽象。然後他們會再上一層……現在這件事變得愈來愈神秘，再也沒人真的懂他們在說些什麼。」

其實這個案例還算好的，因為至少還是個自下而上的抽象化過程，真正可怕的是自上而下，這就好比公司大頭揭示未來的營運方針「我們要為使用者創造價值」之後，底下各級主管就各自再揣摩，定出各部門層級的抽象方針，如此一層一層地往下無根據地具體化，最後做出一個沒有真實感，甚至損及既有使用者價值的東西。

（抽象滲漏法則）

## 重構與分層次地抽象化

舉個例子來說，Python 中，每個模組是一個功能概念，各模組往往會提供一些工廠函式（例如 open()），協助建構常用的物件或處理常見需求，然而，模組中，也會公開工廠函式實作時，所使用到的相關函式與型態（例如 io 模組就是如此），它們的抽象層次更往下一層，使用起來更為複雜，然而卻能用來掌握更多細節，有時，模組中細部的函式與類別，會引用另一更低層次的模組（例如 io 模組使用了 os 模組），一旦習慣了這樣的抽象層次規則，在運用時，就能在胡便性與複雜度掌握之間，取得一個平衝。